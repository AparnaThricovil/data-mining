'''
Created on September 3rd, 2015

@author: Aparna
'''
'''
This program is to read the text file containing closed frequent item sets generated by 
Christian Borgelt's Apriori implementation and to remove the item sets that does not 
contain the class label. 

The input to this program is a text file with each row containing a closed item set.
The output file is also a text file with only closed item sets that has the class label.
'''
from pandas import read_csv
import pandas as pd
import numpy as np
import os
import re
from collections import defaultdict
import csv
import math
import chi2Calculation

def callClosedItemSetProcessing(inputdir,classlabel,inverseLabel,conf):
#input the file
    #inputdir = raw_input("Please enter the location of the input file(C:\Users\Aparna\Anaconda\AprioriResults)")
    def findmax(listItems):
        maxSup=0
        for items in listItems:
            originalFile.seek(0)
            itemCount = 0
            for row in csv_f:
                if items in row:
                    itemCount = itemCount + 1
                if(itemCount>maxSup):
                    maxSup = itemCount
        return maxSup
    for file in os.listdir(inputdir +'/AprioriOutput'):
        if file.endswith(".txt"):
            numofFiles = len(os.listdir(inputdir +'/AprioriOutput'))
            inputFile = open(inputdir +'/AprioriOutput/'+file,'r')
            i=0
            output_file = open(inputdir +'/RemovedUnknown/'+file, "w")
            for line in inputFile:
                if (classlabel in line or inverseLabel in line):
                    i = i+1
                    output_file.write(line)
            output_file.close()
            y=1
            processedfile = open(inputdir +'/RemovedUnknown/'+file, "r")
            itemDict = defaultdict(list)
            for line in processedfile:
                itemList=[]
                for x in line.split(','):
                    if "(" in x:
                        itemList.extend(y.strip() for y in x.split('('))
                    else:
                        itemList.append(x.strip())
                    itemList[-1]=itemList[-1].replace(')','')
                itemDict[i]=itemList
                i = i-1
            minConfidence = conf#raw_input("Please enter the value for minimum confidence")
            originalFile = open(inputdir+'/InputFiles/'+file.split(".")[0]+'.csv')#csv file
            csv_f = csv.reader(originalFile)
            result_file = open(inputdir+'/FinalResults/'+file, "w")#txt file
            #intersection_file = open(inputdir+'/IntersectionFiles/'+file, "w")
            finalResults = defaultdict(list)
            finalResultsdictKey = 0
            for key,value in itemDict.items():
                itemSupport = 0
                originalFile.seek(0)
                listnoSupport = itemDict[key][:-1]
                SupportX_Y = float(itemDict[key][-1])/100
                if inverseLabel in listnoSupport:
                    label = inverseLabel
                    RHS_absent = classlabel
                    listnoSupport.remove(inverseLabel)
                if classlabel in listnoSupport:
                    label = classlabel
                    RHS_absent = inverseLabel
                    listnoSupport.remove(classlabel)
                count = 0
                labelOccurence = 0
                totalNumberTransactions = 0
                A = 0
                B = 0
                C = 0
                D = 0
                for rows in csv_f:
                    totalNumberTransactions = totalNumberTransactions + 1
                    if (set(listnoSupport)<=set(rows)):
                        count = count+1
                    if label in rows:
                        labelOccurence = labelOccurence + 1
                    if label in rows and (set(listnoSupport)<=set(rows)):
                        A = A + 1
                    if RHS_absent in rows and (set(listnoSupport)<=set(rows)):
                        B = B + 1
                    if label in rows and not (set(listnoSupport)<=set(rows)):
                        C = C + 1
                    if RHS_absent in rows and not(set(listnoSupport)<=set(rows)):
                        #print RHS_absent
                        D = D + 1
                #print labelOccurence
                supportX = float(count)/totalNumberTransactions
                supportY = float(labelOccurence)/totalNumberTransactions#support of Y
                chi2 = chi2Calculation.calculate(A,B,C,D)
                IR = (supportY - supportX)/(supportY+supportX-SupportX_Y)
                IR = IR if IR>0 else -1*IR
                kulc=0
                if(supportY!=0):
                    kulc = (SupportX_Y*(supportX+supportY))/(2*supportX*supportY)
                #kulc = (SupportX_Y*(supportX+supportY))/(2*supportX*supportY)
                if(supportX!=0):
                    
                    if((float(SupportX_Y)/supportX) > float(minConfidence)):
                        if not "Unknown" in str(listnoSupport):
                            finalResultsdictKey = finalResultsdictKey + 1
                            if (float(SupportX_Y)/supportX > 1.0):
                                Confidence = float(1.00)
                            else:
                                Confidence = float(SupportX_Y)/supportX
                            lift = float(Confidence)/supportY
                            itemList = listnoSupport[:]
                            itemList.append(label)
                            allConf = float(count)/findmax(itemList)
                            cosine = float(SupportX_Y)/math.sqrt(supportX * supportY)
                            dictValue = [round(cosine,3),round(Confidence,3),listnoSupport,label,round(SupportX_Y,3),round(lift,3),round(allConf,3),round(chi2,3),round(IR,3),round(kulc,3)]
                            finalResults[finalResultsdictKey].append(dictValue)
            rulesID = 0
            result_file.write("#ID\t")
            result_file.write("Rule\t")
            result_file.write("Support\t")
            result_file.write("Confidence\t")
            result_file.write("Cosine\t")
            result_file.write("IR\t")
            result_file.write("Kulc\n")
            for key, value in finalResults.items():
                rulesID = rulesID + 1
                result_file.write("%s " % str(rulesID))#ID
                result_file.write("\t%s" % str(value[0][2]))#antecedant
                result_file.write("--->")
                result_file.write(str(value[0][3]))#consequent
                result_file.write(" \t%s " % str(value[0][4]))#Support
                result_file.write("\t%s " % str(value[0][1]))#Confidence
                result_file.write("\t%s " % str(value[0][0]))#Cosine
                #result_file.write("\t%s " % str(value[0][5]))#Lift
                #result_file.write("\t%s " % str(value[0][6]))#All confidence
                #result_file.write("\t%s " % str(value[0][7]))#Chi2
                result_file.write("\t%s " % str(value[0][8]))#IR
                result_file.write("\t%s " % str(value[0][9]))#kulc
                result_file.write("\n")
                '''intersection_file.write(str(value[0][2]))
                intersection_file.write(str(value[0][3]))
                intersection_file.write("\n")'''
        	#result_file.close()
        	#intersection_file.close()
    rules = [set() for i in range(numofFiles)]
    index = 0
    '''for file in os.listdir(inputdir +'/IntersectionFiles/'):
        if file.endswith(".txt"):
        	print file
        	rules[index] = set(open(inputdir +'/IntersectionFiles/'+file,'r'))
        	index = index + 1
    intersectionRules = set.intersection(*rules)'''
    '''results = open(inputdir+'/GlobalRules.txt', "w")#txt file
    for item in list(intersectionRules):
    	anteConse = item.split(']')
    	results.write(str(anteConse[0]))
    	results.write("]--->")
    	results.write(str(anteConse[1]))'''
    #results.close()
    return